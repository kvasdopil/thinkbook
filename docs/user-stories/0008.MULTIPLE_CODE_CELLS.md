# 0008.multiple-code-cells

## Background

Currently the notebook supports a single editable Python cell, which limits how users can structure and iterate on their work. Allowing multiple independent cells — each with its own output and execution controls — will provide a more familiar, flexible workflow akin to traditional Jupyter notebooks.

## User Story

> **As a** data-driven developer
> **I want** to add, run, and remove multiple code cells in my notebook
> **So that** I can organise complex scripts into logical, reusable chunks and rerun them efficiently.

## Acceptance Criteria

1. A "Run All" button is displayed above the cell list; clicking it executes every cell sequentially from top to bottom.
2. A "+ Add Cell" button (or equivalent UI affordance) lets the user insert a new, empty code cell at the end of the list.
3. A single AI chat interface is displayed at the top of the page (after the title, before the control buttons) that can interact with all cells in the notebook.
4. Each code cell includes:
   - a code editor area (Monaco)
   - an output area that displays only the cell's stdout/stderr or error trace
   - a status/run/stop button reflecting the current state (new, running, success, error, cancelled) using existing visual styles.
5. Output is cleared immediately when the cell begins execution.
6. A delete icon button (e.g. `FaTrash`) is visible on each cell; clicking removes that cell after user confirmation.
7. Keyboard focus order and screen-reader labels meet WCAG 2.1 AA accessibility requirements.
8. All new UI controls follow the project rule of using `react-icons` for icons.
9. When a cell is running it should not be editable
10. When any cell is running, 'run all' should be disabled

## Execution State Requirements

**CRITICAL**: The following execution state transitions must be strictly enforced to prevent regressions:

11. **Successful execution**: Cell ends in **COMPLETE** state (green indicator)

    - Worker sends `execution-complete` message
    - Cell shows green checkmark icon when complete
    - Cell can be re-run by clicking status button

12. **User cancellation/interruption**: Cell ends in **CANCELLED** state (orange indicator)

    - User clicks stop button while cell is running
    - Worker sends `execution-cancelled` message (NOT `execution-complete`)
    - Cell shows orange X icon when cancelled
    - Cell can be re-run by clicking status button

13. **Python exceptions/errors**: Cell ends in **FAILED** state (red indicator)

    - Any Python exception (except KeyboardInterrupt) should be re-raised after logging
    - Worker sends `error` message (NOT `execution-complete`)
    - Cell shows red X icon when failed
    - Cell can be re-run by clicking status button

14. **Stop button visibility**: When cell is in RUNNING state and user hovers over status button:
    - Button must show stop icon (FaStop) and "Stop" text
    - Button must be clickable and trigger cancellation
    - Button must never be missing or non-functional during execution

## Output Handling Requirements

**CRITICAL**: The following output requirements must be strictly enforced:

15. **Cell-specific output**: Each cell displays only its own execution output

    - Output must be isolated per cell
    - No global output area that affects multiple cells

16. **System message filtering**: Cell output areas must NEVER show system messages

    - No "Running..." messages in cell output
    - No "Execution completed" messages in cell output
    - No "Execution cancelled" messages in cell output
    - Only actual Python stdout/stderr should be displayed

17. **Output clearing**: Cell output is completely cleared when execution begins

    - Previous output is immediately removed when run button is clicked
    - No delay or flashing of old output

18. **Real-time output**: Cell output appears in real-time during execution
    - Print statements appear immediately as they execute
    - No batching or delays in output display

## State Management Requirements

**CRITICAL**: To prevent React closure issues:

19. **Execution tracking**: Use refs (not state) for tracking currently executing cell

    - `currentExecutingCellIdRef` must be used instead of state
    - Worker message handlers must access current values via refs
    - State closures must be avoided in worker message handling

20. **Output routing**: Worker messages must be routed to correct cell
    - `currentExecutingCellIdRef.current` must never be null during execution
    - Output lines must be associated with correct cell ID

## AI Chat Interface Requirements

**CRITICAL**: The following AI chat interface requirements must be strictly enforced:

21. **Single chat interface**: There must be exactly ONE AI chat interface on the page

    - Located at the top of the page after the title, before control buttons
    - Not embedded within individual code cells
    - Can interact with all cells in the notebook

22. **Multi-cell AI functions**: The chat interface must support multi-cell operations

    - `listCells` function returns data for all cells in the notebook
    - `updateCell` function can modify any cell by ID
    - Chat interface receives `getCellsData` and `onMultiCellUpdate` props

23. **Chat interface isolation**: The chat interface is independent of individual cells
    - Adding/deleting cells does not affect the chat interface
    - Chat interface state is preserved when cells are modified
    - No chat-related props are passed to individual CodeCell components

## Out of Scope

- Re-ordering cells via drag-and-drop.
- Persisting cell list to backend or localStorage.

## Potential Pitfalls

- Ensuring output clearing does not flash previous output before disappearance.
- Managing sequential execution timing and cancellation during a "Run All" sequence.
- **React state closures**: Worker message handlers capturing stale state values
- **Execution state confusion**: Cells ending up in wrong state (complete vs cancelled vs failed)
- **System message leakage**: Internal system messages appearing in user-visible output
- **Chat interface duplication**: Accidentally rendering ChatInterface in each cell instead of once at page level

## Definition of Done

- [ ] All acceptance criteria are met
- [ ] All execution state requirements are enforced
- [ ] All output handling requirements are implemented
- [ ] All state management requirements are followed
- [ ] All AI chat interface requirements are implemented
- [ ] Unit / integration tests pass
- [ ] Lint & type-check succeed
- [ ] Documentation README is updated
- [ ] Manual testing confirms no regressions in execution states
- [ ] Manual testing confirms output isolation and real-time display
- [ ] Manual testing confirms single chat interface at page top (not per cell)
- [ ] Manual testing confirms AI functions work with all cells from single interface
