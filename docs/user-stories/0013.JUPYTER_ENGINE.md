# 0013.jupyter-engine

## Background

The app needs a Python execution environment in the browser to run code cells. Pyodide provides Python runtime via WebAssembly, while Monaco Editor handles syntax highlighting and editing.

## User Story

> **As a** user  
> **I want** to write Python code in a syntax-highlighted editor and execute it  
> **So that** I can run Python scripts and see their output in my browser.

## Acceptance Criteria

1. A textarea with Python syntax highlighting is displayed on the main page
2. A "Run" button executes the Python code using Pyodide in a web worker
3. Code output (print statements, errors) appears below the editor
4. Editor uses Monaco Editor with proper Python language support
5. Pyodide loads from CDN https://cdn.jsdelivr.net/pyodide/v0.28.0/full/
6. Python execution is isolated in a web worker for performance
7. Worker remains stable during parent component re-renders and callback changes

## Technical Notes

- **Editor**: Monaco Editor for syntax highlighting and code editing
- **Python Runtime**: Pyodide 0.28.0 loaded from CDN
- **Architecture**: Web Worker isolates Python execution from main thread
- **Output**: Plain-text stdout/stderr only (rich display out of scope)
- **Packages**: Default Pyodide packages only (no additional wheels)
- **Worker Bundling**: Use Vite bundling via `new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' })`
- **Worker Lifecycle**: Worker must persist across parent re-renders to prevent execution interruption

## Test Scenarios

### Worker Lifecycle Stability

1. **Worker Persistence During Re-renders**: Worker instance must not restart when parent component re-renders with new callback references
2. **Execution State Continuity**: Code execution must continue uninterrupted even if parent component re-renders during execution
3. **Callback Reference Changes**: Worker must remain stable when `onOutputChange` or other callbacks get new function references
4. **Memory Management**: Worker should be created only once per component lifecycle and properly terminated on unmount
5. **Output Delivery**: All output must be delivered correctly even after parent re-renders change callback dependencies

### Required Test Coverage

- Test parent component re-renders with changing callback dependencies during worker initialization
- Test code execution that continues across multiple parent re-renders
- Test output streaming that survives callback reference changes
- Test worker instance counting to ensure no excessive worker creation/termination
- Test execution state persistence when component props change frequently

## Potential Pitfalls

- **Function naming conflicts**: Don't name worker functions same as imported library globals (e.g., avoid `loadPyodide()` when importing Pyodide)
- **Code injection safety**: Use `pyodide.globals.set()` and `exec()` instead of template literals to prevent JavaScript parsing errors
- **TypeScript setup**: Include `/// <reference lib="webworker" />` and `DedicatedWorkerGlobalScope` type
- **CDN consistency**: Ensure `indexURL` matches the CDN version used in `importScripts()`
- **React Strict Mode**: Multiple worker initialization attempts in development are expected behavior
- **useEffect Dependencies**: CRITICAL - Never include callback functions in worker useEffect dependencies as this causes worker restart on every parent re-render
- **Worker Termination**: Ensure worker is terminated only on component unmount, not on prop/callback changes
- **Execution Interruption**: Worker restarts during execution will lose all output and state

## Definition of Done

- All acceptance criteria are met
- Unit / integration tests pass, including worker lifecycle stability tests
- Lint & type-check succeed
- Python code executes successfully in web worker
- Output displays correctly below editor
- Worker remains stable during parent component re-renders
- All test scenarios for worker lifecycle are covered
