# Background

The current Jupyter notebook engine executes Python code and displays output only after the script completes execution. This creates a poor user experience for scripts that produce output over time, as users cannot see intermediate results or progress.

# User story

- When a user runs Python code that produces output over time (e.g., with `print()` statements and `time.sleep()`), the output should appear in real-time as it's being generated
- Each `print()` statement should immediately display its output in the output area, not wait for the entire script to finish
- The user should be able to see the progression of long-running scripts as they execute
- The streaming output should work seamlessly with the existing run button and output display

# Example scenario

When a user runs this code:

```python
import time

for a in range(0,10):
    time.sleep(1)
    print("hello " + str(a))
```

The expected behavior is:

- "hello 0" appears after 1 second
- "hello 1" appears after 2 seconds
- "hello 2" appears after 3 seconds
- And so on...

Instead of all output appearing at once after 10 seconds.

# Implementation considerations

- The streaming output should work with the existing Pyodide web worker architecture
- Output should be captured and sent to the main thread as it's generated, not buffered until completion
- The UI should append new output lines progressively without clearing previous output
- Error handling should still work properly during streaming execution
- The run button should remain disabled during execution to prevent multiple simultaneous runs

## Implementation details (clarified)

- The Web Worker must post a message to the main thread **immediately after every `print()` or rich `display()` call** so that output arrives with per-call granularity
- Output messages should have shape `{ type: "out" | "err", value: string }` enabling flexible client-side rendering (stdout in default style, stderr in red, etc.)
- The output pane should **auto-scroll to the bottom** whenever new output arrives _if_ the user is already at the bottom; otherwise leave scroll position untouched
- There is **no maximum log size** for now; keep appending lines indefinitely
- Cancel / interrupt functionality is **out of scope** for this story

## Implementation gotchas and lessons learned

**Critical issues to avoid when implementing streaming output:**

### 1. DataCloneError with js.postMessage()

- **Problem**: Trying to call `js.postMessage()` directly from Python code causes `DataCloneError: [object Object] could not be cloned`
- **Solution**: Use JavaScript callback functions set via `pyodide.globals.set()` instead of direct `js.postMessage()` calls
- **Working pattern**:
  ```javascript
  pyodide.globals.set("send_output", (output_type, text) => {
    ctx.postMessage({ type: output_type, value: text, id });
  });
  ```

### 2. Keyword Argument Conflicts in print() Redefinition

- **Problem**: When redefining `print()`, passing `file=buffer` alongside `**kwargs` causes `TypeError: got multiple values for keyword argument 'file'`
- **Solution**: Create a copy of kwargs and set the file parameter explicitly
- **Working pattern**:
  ```python
  def streaming_print(*args, **kwargs):
      kwargs_copy = kwargs.copy()
      kwargs_copy['file'] = buffer
      original_print(*args, **kwargs_copy)
  ```

### 3. Infinite Recursion in print() Redefinition

- **Problem**: Calling both `original_print(*args, **kwargs)` and `builtins.print(*args, **kwargs_copy)` in the same function causes infinite recursion
- **Solution**: Only call `original_print` once, using it to write to the buffer
- **Anti-pattern**:
  ```python
  # DON'T DO THIS - causes infinite recursion
  builtins.print(*args, **kwargs_copy)  # writes to buffer
  original_print(*args, **kwargs)       # calls our function again!
  ```
- **Working pattern**:
  ```python
  # DO THIS - use original_print only once
  original_print(*args, **kwargs_copy)  # writes to buffer only
  ```

### 4. Message Type Synchronization

- **Problem**: Worker and main thread must use consistent message types. Updating one without the other causes "Unknown message type" errors
- **Better solution**: Create a shared types file that both worker and main thread import
- **Recommended pattern**:

  ```typescript
  // types/worker-messages.ts
  export interface WorkerOutputMessage {
    type: "out" | "err";
    value: string;
    id: string;
  }

  export interface WorkerStatusMessage {
    type: "execution-complete" | "error" | "init-complete";
    message?: string;
    id?: string;
  }

  export type WorkerMessage = WorkerOutputMessage | WorkerStatusMessage;
  ```

- **Usage**: Import and use these types in both `pyodide-worker.ts` and `page.tsx`
- **Key message types**: `"out"`, `"err"`, `"execution-complete"`, `"error"`, `"init-complete"`

### 5. Proper Function Restoration

- **Problem**: Not restoring original `print` and `sys.stderr` can cause issues with subsequent executions
- **Solution**: Always restore original functions in a `finally` block
- **Working pattern**:
  ```python
  try:
      exec(user_code, globals())
  except Exception as e:
      # handle errors
  finally:
      builtins.print = original_print
      sys.stderr = original_stderr
  ```

# Technical requirements

- Maintain compatibility with existing Pyodide setup and Monaco Editor
- Use web worker message passing to stream output from worker to main thread
- Implement proper stdout/stderr capture that flushes immediately
- Handle both synchronous and asynchronous output generation patterns
- Preserve existing error handling and execution state management
