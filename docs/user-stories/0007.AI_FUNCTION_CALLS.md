# 0007 – AI Agent Function Calls

## Summary

Implement structured **AI function calls** so that the inline chat assistant can directly interact with notebook code cells.  
This story introduces two initial functions — `listCells` and `updateCell` — and defines the architecture rules for adding more functions in the future.

## Motivation

End-users want to ask the AI assistant to read or modify notebook cells without copy-pasting code. Explicit function calls allow:

- Deterministic, auditable actions (vs. free-form natural language)
- Fine-grained UI feedback on execution status
- A scalable pattern for adding more capabilities over time

## Functional Requirements

1. **Function Definitions**
   1. Each function **lives in its own file** under `app/ai-functions/` (create this folder if it does not exist).
   2. A function file exports **only metadata** on the server (prompt, name, parameters schema, description).  
      No business logic must run on the backend.
   3. The **frontend** imports the same file and supplies the actual implementation.
   4. **CRITICAL**: Function parameters must use **Zod schemas**, not JSON schemas, as required by the Vercel AI SDK.
2. **Initial Functions**
   | Name | Parameters | Return | Description |
   |------|------------|--------|-------------|
   | `listCells` | none | `Array<{ id: number; type: "code" \| "markdown"; text: string; output?: string }>` | Returns a snapshot of every cell in the current notebook. The output field is **only** present for code cells. |
   | `updateCell` | `id: number`, `text: string` | `{ updated: true }` | Replaces the cell's contents with the new `text`. |
   Notes:
   - For MVP we have **exactly one cell**, but the API must be future-proof.
3. **UI Presentation**
   1. A function call is rendered as its **own conversation balloon** in the chat history.
   2. Balloon color indicates status:
      - _In-progress_: blue‐tinted background, spinning icon
      - _Success_: green background, check icon
      - _Failure_: red background, error icon
      - _Cancelled_: orange background, stop icon
   3. The assistant's natural-language response appears **after** the call balloon.
   4. **CRITICAL**: Function calls should be rendered using `message.toolInvocations` from the Vercel AI SDK to prevent duplication.
4. **Invocation Flow**
   1. Gemini response must use the [OpenAI function-calling JSON schema](https://platform.openai.com/docs/guides/function-calling) equivalent understood by the Vercel AI SDK.
   2. Frontend detects the tool call, looks up the registered implementation, executes it, and streams status updates to the UI.
   3. If the user cancels, the call transitions to _cancelled_ state; no further side-effects should occur.
5. **Extensibility**
   - Adding a new function requires **only** creating another file in `app/ai-functions/` following the same pattern.
   - Shared TypeScript types live in `types/ai-functions.ts`.
6. Cancel button is out of scope for now
7. Functions should be called one-by-one

## Implementation Guidelines

### **Schema Definition**

- Use Zod for parameter validation: `z.object({ param: z.string().describe("Description") })`
- Export both the schema and metadata from each function file
- Use `z.infer<typeof schema>` for TypeScript type inference

### **Function Call Rendering**

- Store function calls in a `Record<string, AIFunctionCall>` keyed by `toolCallId`
- Render function calls using `message.toolInvocations?.map()` to prevent duplication
- Each function call should appear exactly once, associated with its specific message

### **State Management**

- Use `onToolCall` callback from `useChat` to handle function execution
- Update function call status using the `toolCallId` as the key
- Validate parameters with Zod's `.parse()` method before execution

### **API Integration**

- Pass Zod schemas directly to the `tools` parameter in `streamText`
- The Vercel AI SDK will handle schema validation automatically
- Function metadata should include `parameters: zodSchema` (not JSON schema)

## Non-Functional Requirements

- TypeScript everywhere with strict‐null-checks.
- React components must remain accessible (ARIA roles, focus states).
- No server-side execution of notebook-manipulating code.
- Unit tests for each function's frontend implementation (Jest + React Testing Library).
- **CRITICAL**: Zod schemas must be used for all function parameters to ensure compatibility with Vercel AI SDK.

## Acceptance Criteria

- [ ] Calling `listCells` from the chat returns the current cell array and shows a green _Success_ balloon.
- [ ] Calling `updateCell` with the ID of the single existing cell updates its contents and shows a green _Success_ balloon.
- [ ] Invalid parameters yield a red _Failure_ balloon with an error message.
- [ ] Cancelling mid-execution yields an orange _Cancelled_ balloon and aborts processing.
- [ ] README rules regarding function file placement and icon usage are followed.
- [ ] Function calls appear exactly once in the conversation (no duplication).
- [ ] Function parameters are validated using Zod schemas.

## Common Pitfalls to Avoid

1. **Schema Type Mismatch**: Always use Zod schemas, never JSON schemas
2. **Function Call Duplication**: Use `message.toolInvocations` instead of manual filtering
3. **State Management**: Store function calls by `toolCallId` to avoid conflicts
4. **Parameter Validation**: Always validate with Zod before executing functions
5. **Rendering Logic**: Don't render function calls after every user message; use the AI SDK's associations

---

**Estimated Effort:** 2 story points
