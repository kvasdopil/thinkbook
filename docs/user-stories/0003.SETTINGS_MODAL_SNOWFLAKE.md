# 0003.settings-modal-snowflake

## Background

The Snowflake SQL integration currently relies on a hard-coded `SNOWFLAKE_BASE_URL` environment variable and expects callers to supply an access token only via an HTTP header. This limits flexibility: developers cannot point the notebook at different Snowflake accounts or rotate access tokens without redeploying the application. Extending the existing settings modal (introduced in story **0002**) to collect the Snowflake **Access Token** and **Hostname** empowers users to configure Snowflake connectivity entirely from the UI and removes the need for server-side environment variables.

## User Story

> **As a** developer using the notebook
> **I want** to enter my Snowflake access token and hostname via the settings modal
> **So that** I can run SQL queries against any Snowflake account without editing environment variables or redeploying the app

## Acceptance Criteria

1. The settings modal now includes two additional inputs:
   - "Snowflake Access Token" (masked as password)
   - "Snowflake Hostname" (plain text)
2. The modal auto-opens **once** on application startup when **any** of the following values is missing from storage:
   - Gemini AI Key
   - Snowflake Access Token
   - Snowflake Hostname
3. Pressing **OK** in the modal:
   - Persists both Snowflake values to `localStorage` using the dedicated storage helper (`src/utils/storage.ts`).
   - Closes the modal.
4. Pressing **Cancel** or clicking the backdrop closes the modal **without** saving changes.
5. All frontend calls to the SnowflakeService now use the stored values:
   - Access token from localStorage for authentication
   - Hostname from localStorage to construct the API URL
6. The SnowflakeService:
   - Reads both access token and hostname from localStorage.
   - Constructs the Snowflake REST URL using the provided hostname (`https://<hostname>/api/v2/statements` â€¦).
   - Throws descriptive errors when either value is missing from storage.
7. If an HTTP 400 error is returned, the error message is surfaced in the AI chat interface.
8. The modal, inputs, and buttons meet accessibility requirements (ARIA labels, focus trapping, keyboard navigation). The new inputs follow the same styling and UX patterns as the existing Gemini Key field.
9. Comprehensive unit and integration tests cover:
   - Modal rendering and auto-open logic
   - Storage helper read/write for new keys
   - Configuration usage in SnowflakeService calls
   - Service error handling and URL construction
   - Error propagation to the UI
10. README is updated to list this implemented story.

## Technical Notes

- Persist values with `localforage.setItem('snowflake-access-token', token)` and `localforage.setItem('snowflake-hostname', hostname)`.
- Retrieve with the corresponding `getItem` calls and expose them via a `useSnowflakeConfig()` React hook that refreshes consumers when values change.
- Update the existing SnowflakeService to use both stored values automatically.
- Remove all references to environment variables and backend endpoints from the codebase and tests.

## Potential Pitfalls

- Forgetting to await `localforage` promises can cause headers to be missing in the first request.
- Hostname values that include protocol prefixes (`https://`) should be normalised or rejected to avoid double prefixes.

## Definition of Done

- All acceptance criteria are met
- Unit / integration tests pass
- Lint & type-check succeed
- Documentation (README, user story list) is updated
