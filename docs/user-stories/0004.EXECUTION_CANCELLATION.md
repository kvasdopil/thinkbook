# Background

The current Jupyter notebook engine can execute Python code with streaming output, but long-running scripts cannot be interrupted once started. Users need the ability to cancel execution of scripts that take too long, get stuck in infinite loops, or are no longer needed.

# User story

- When Python code is executing in Pyodide, a "Stop" button should appear in the UI alongside or replacing the "Run" button
- The "Stop" button should be clearly visible and accessible to users during execution
- When the user clicks "Stop", the UI should immediately show a "stopping" state to indicate cancellation is in progress
- The Python script execution should be cancelled immediately using SharedArrayBuffer interruption
- The UI should indicate that the execution was cancelled (not just completed)
- After cancellation, the "Run" button should be available again to execute new code
- The output should show that execution was cancelled, not that it completed successfully
- The system should display an error if SharedArrayBuffer is not available

# Example scenario

When a user runs this code:

```python
import time

for i in range(0, 10):
    time.sleep(1)
    print('hello' + str(i))
```

The expected behavior is:

1. User clicks "Run Code" - button changes to "Stop" (or "Stop" appears alongside)
2. Script starts executing: "hello0", "hello1", "hello2" appear with 1-second intervals
3. User clicks "Stop" after seeing "hello2"
4. Button immediately changes to "Stopping..." and becomes disabled
5. Output shows "Stopping execution..." message
6. Execution stops immediately (no "hello3", "hello4", etc.)
7. Output shows "Execution interrupted by user" message
8. "Run Code" button becomes available again
9. User can run new code

# Technical requirements

- Cancellation should work with the existing Web Worker architecture
- Use SharedArrayBuffer with `pyodide.setInterruptBuffer()` for immediate cancellation
- The cancellation mechanism should be safe and not leave Pyodide in an inconsistent state
- After cancellation, the environment should be ready for new code execution
- Cancellation should work with any Python code, including tight loops without print statements
- The UI should provide clear feedback about the cancellation state including:
  - "Running" state when code is executing
  - "Stopping" state when cancellation is requested but not yet confirmed
  - "Cancelled" state when cancellation is complete
- The "Stop" button should be disabled during the "stopping" state to prevent multiple cancellation requests
- The system should detect SharedArrayBuffer availability and show error when not available
- Required security headers must be set for SharedArrayBuffer support

# Implementation approach

## Core Cancellation Strategy

- **SharedArrayBuffer Interruption**: Use `pyodide.setInterruptBuffer()` with SharedArrayBuffer for immediate cancellation
- **Error Handling**: Use standard Python `KeyboardInterrupt` for SharedArrayBuffer cancellation
- **Immediate Response**: SharedArrayBuffer provides instant cancellation for any Python code

## Security Requirements

- **Cross-Origin-Embedder-Policy**: `require-corp` header must be set
- **Cross-Origin-Opener-Policy**: `same-origin` header must be set
- **SharedArrayBuffer Detection**: Check availability and show error when not available

## Web Worker Communication

- Add message type `"setInterruptBuffer"` to share SharedArrayBuffer with worker
- Keep `"cancel"` message type for triggering cancellation
- Add `"execution-cancelled"` message type for cancellation confirmation
- Worker uses `pyodide.setInterruptBuffer()` to enable immediate cancellation

## UI Changes

- Replace "Run Code" button with "Stop" button during execution
- Show "Stopping..." button state when cancellation is requested
- Update button states and styling to clearly indicate cancellation capability
- Show "Stopping execution..." message when cancellation is requested
- Show "Execution interrupted by user" message when cancellation occurs
- Show error message when SharedArrayBuffer is not available
- Add proper state management for running/stopping/cancelled states
- Show SharedArrayBuffer status in UI

## Python Execution Interruption Implementation

- Worker sets interrupt buffer with `pyodide.setInterruptBuffer(buffer)`
- Main thread sets `buffer[0] = 2` to trigger `SIGINT`
- Python code catches `KeyboardInterrupt` naturally
- Worker returns error if SharedArrayBuffer is not available

## Error Handling

- Detect SharedArrayBuffer availability and provide error messages when not available
- Handle `KeyboardInterrupt` for SharedArrayBuffer cancellation
- Graceful handling of cancellation during different execution phases
- Ensure cancellation doesn't corrupt the Python environment state

## State Management

- Add cancellation state tracking alongside execution state
- Add "stopping" state to provide immediate feedback during cancellation
- SharedArrayBuffer state tracking and proper cleanup
- Reset interrupt buffer for new executions
- Handle race conditions between natural completion and cancellation

# Implementation challenges and considerations

## Challenge 1: SharedArrayBuffer Availability

- **Problem**: SharedArrayBuffer requires specific security headers and browser support
- **Considerations**:
  - Required headers: `Cross-Origin-Embedder-Policy: require-corp`, `Cross-Origin-Opener-Policy: same-origin`
  - Not all browsers or deployment environments support these headers
  - Need proper detection and error handling when not available
  - Clear user communication about limitations

## Challenge 2: Browser Compatibility

- **Problem**: SharedArrayBuffer support varies across browsers and contexts
- **Considerations**:
  - Some browsers disable SharedArrayBuffer in certain contexts
  - Need to handle detection and show appropriate error messages
  - Provide clear feedback to users about cancellation availability

## Challenge 3: Race Conditions

- **Problem**: Cancellation request might arrive just as execution completes naturally
- **Considerations**:
  - Handle cases where cancellation and completion happen simultaneously
  - Ensure UI state reflects the actual outcome
  - Prevent duplicate completion/cancellation messages

## Challenge 4: User Experience During Cancellation

- **Problem**: Need to provide clear feedback about cancellation state
- **Considerations**:
  - "Stopping" state provides immediate feedback to users
  - Disabled "Stopping..." button prevents multiple cancellation requests
  - Clear messaging helps users understand the process

## Challenge 5: Pyodide-Specific Implementation Details

- **Problem**: This implementation is tightly coupled to Pyodide's interrupt system
- **Considerations**:
  - `pyodide.setInterruptBuffer()` API is specific to Pyodide and may change in future versions
  - Interrupt signal value (2 = SIGINT) is Pyodide-specific
  - Python `KeyboardInterrupt` behavior depends on Pyodide's implementation
  - Other Python-in-browser solutions may have different interrupt mechanisms
  - Need to handle Pyodide version compatibility

## Challenge 6: SharedArrayBuffer Message Passing Implementation

- **Problem**: SharedArrayBuffer must be properly transferred and managed between main thread and worker
- **Considerations**:
  - SharedArrayBuffer creation must happen before worker initialization
  - Buffer must be transferred via `postMessage` with correct message structure
  - Worker must call `pyodide.setInterruptBuffer()` after Pyodide initialization
  - Main thread sets interrupt signal by writing to buffer[0] = 2
  - Worker must clear buffer[0] = 0 for new executions

## Challenge 7: Security Headers and Deployment Requirements

- **Problem**: SharedArrayBuffer requires specific security headers that affect deployment
- **Considerations**:
  - Must set `Cross-Origin-Embedder-Policy: require-corp` header
  - Must set `Cross-Origin-Opener-Policy: same-origin` header
  - Headers must be configured in web server or framework (Next.js, etc.)
  - HTTPS is required for SharedArrayBuffer in production
  - Headers may conflict with other security policies or third-party integrations

# Success criteria

- User can cancel any running Python script by clicking a "Stop" button
- UI immediately shows "Stopping..." state when cancellation is requested
- Cancellation happens immediately for any Python code
- UI clearly indicates when execution has been cancelled vs. completed
- Python environment remains stable and usable after cancellation
- New code can be executed immediately after cancellation
- System detects and shows error when SharedArrayBuffer is not available
- Users understand that cancellation requires SharedArrayBuffer support
- Clear error messages when SharedArrayBuffer is not available

# Out of scope

- Partial execution preservation (cancelled execution should not leave partial results)
- Graceful shutdown mechanisms for specific types of operations
- Advanced cancellation options (e.g., timeout-based cancellation)
- Integration with specific Python libraries that might have their own cancellation mechanisms
- Fallback cancellation mechanisms when SharedArrayBuffer is not available
- Automatic enablement of security headers in all deployment environments (deployment-specific configuration required)
