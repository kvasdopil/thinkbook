# 0014.settings-modal-snowflake

## Background

The Snowflake SQL integration currently relies on a hard-coded `SNOWFLAKE_BASE_URL` environment variable and expects callers to supply an access token only via an HTTP header. This limits flexibility: developers cannot point the notebook at different Snowflake accounts or rotate access tokens without redeploying the application. Extending the existing settings modal (introduced in story **0013**) to collect the Snowflake **Access Token** and **Hostname** empowers users to configure Snowflake connectivity entirely from the UI and removes the need for server-side environment variables.

## User Story

> **As a** developer using the notebook
> **I want** to enter my Snowflake access token and hostname via the settings modal
> **So that** I can run SQL queries against any Snowflake account without editing environment variables or redeploying the app

## Acceptance Criteria

1. The settings modal now includes two additional inputs:
   - "Snowflake Access Token" (masked as password)
   - "Snowflake Hostname" (plain text)
2. The modal auto-opens **once** on application startup when **any** of the following values is missing from storage:
   - Gemini AI Key
   - Snowflake Access Token
   - Snowflake Hostname
3. Pressing **OK** in the modal:
   - Persists both Snowflake values to `localStorage` using the dedicated storage helper (`src/utils/storage.ts`).
   - Closes the modal.
4. Pressing **Cancel** or clicking the backdrop closes the modal **without** saving changes.
5. All frontend requests to `/api/snowflake` now include two HTTP headers:
   - `x-snowflake-access-token: <stored token>`
   - `x-snowflake-hostname: <stored hostname>`
6. The backend `/api/snowflake` route:
   - Reads `x-snowflake-access-token` **and** `x-snowflake-hostname` from the request headers.
   - Constructs the Snowflake REST URL using the provided hostname (`https://<hostname>/api/v2/statements` â€¦).
   - Ignores and **removes** any reference to the `SNOWFLAKE_BASE_URL` environment variable.
   - Returns HTTP 400 with a descriptive message when either header is missing.
7. If an HTTP 400 error is returned, the error message is surfaced in the AI chat interface.
8. The modal, inputs, and buttons meet accessibility requirements (ARIA labels, focus trapping, keyboard navigation). The new inputs follow the same styling and UX patterns as the existing Gemini Key field.
9. Comprehensive unit and integration tests cover:
   - Modal rendering and auto-open logic
   - Storage helper read/write for new keys
   - Header injection in frontend Snowflake API calls
   - Backend header validation and URL construction
   - Error propagation to the UI
10. README is updated to list this implemented story.

## Technical Notes

- Persist values with `localforage.setItem('snowflake-access-token', token)` and `localforage.setItem('snowflake-hostname', hostname)`.
- Retrieve with the corresponding `getItem` calls and expose them via a `useSnowflakeConfig()` React hook that refreshes consumers when values change.
- Update the existing Snowflake API wrapper/fetch hook to append both headers automatically.
- Remove all usages of `SNOWFLAKE_BASE_URL` from the codebase and tests.

## Potential Pitfalls

- Forgetting to await `localforage` promises can cause headers to be missing in the first request.
- Hostname values that include protocol prefixes (`https://`) should be normalised or rejected to avoid double prefixes.

## Definition of Done

- All acceptance criteria are met
- Unit / integration tests pass
- Lint & type-check succeed
- Documentation (README, user story list) is updated
