# Background

The app should implement jypeter notebook engine in a web worker and render some ui for them

# User story

- On a main page user should see a textarea with code, and a 'run' button
- Textarea should be editable, and should have syntax highlight for python
- No editor settings that need be configurable
- When run is pressed the code should be executed by pyodide environment running in a web worker
- Code output (via print and display) should be displayed under the textarea

# Implementation details (clarified)

The following choices were agreed upon during clarification:

- **Editor**: Use **Monaco Editor** for the code textarea, configured with Python syntax highlighting.
- **Pyodide source**: Load Pyodide from https://cdn.jsdelivr.net/npm/pyodide@0.28.0/pyodide.min.js. No requirement to self-host the files.
- **Web Worker bundling**: Let Next.js bundle the Web Worker via `new Worker(new URL('./worker.ts', import.meta.url))` (or equivalent) rather than serving a static asset.
- **Output support**: For now, only plain-text stdout/stderr should be captured and rendered under the editor. Rich display output (e.g. images) is out of scope.
- **Extra Python packages**: Rely solely on the default packages shipped with Pyodide. No additional wheels need to be preloaded.

# Implementation gotchas and best practices

**Critical issues to avoid when implementing:**

## 1. Web Worker Function Naming Conflicts with External Libraries

- **Problem**: When importing external libraries via `importScripts()`, avoid naming your functions the same as global functions exposed by the library. This causes infinite recursion when your function tries to call itself instead of the library function.
- **Solution**: Use descriptive, unique function names that won't conflict with imported globals. Examples: `loadPyodideWorker()`, `initializeLibrary()`, `setupExternalScript()`.
- **Specific case**: Don't name your function `loadPyodide()` when importing Pyodide, as it exposes a global `loadPyodide()` function.

## 2. Python Code Execution Safety

- **Problem**: Using template literals to inject user code directly into Python strings can cause JavaScript parsing errors if the code contains backticks or `${}`.
- **Anti-pattern**:
  ```javascript
  pyodide.runPython(`
  with redirect_stdout(stdout_buffer):
      ${userCode}  // DANGEROUS!
  `);
  ```
- **Solution**: Use `pyodide.globals.set()` to safely pass code and execute with `exec()`:
  ```javascript
  pyodide.globals.set("user_code", code);
  pyodide.runPython(`
  with redirect_stdout(stdout_buffer):
      exec(user_code, globals())
  `);
  ```

## 3. TypeScript Interface Completeness

- **Problem**: The `PyodideInterface` needs to include the `globals` property for TypeScript to work properly.
- **Solution**: Include in your interface:
  ```typescript
  interface PyodideInterface {
    // ... other properties
    globals: {
      set: (name: string, value: unknown) => void;
      get: (name: string) => unknown;
    };
  }
  ```

## 4. Web Worker TypeScript Setup

- **Required**: Add `/// <reference lib="webworker" />` at the top of your worker file
- **Required**: Use `DedicatedWorkerGlobalScope` type for proper worker context
- **Pattern**:
  ```typescript
  /// <reference lib="webworker" />
  const ctx: DedicatedWorkerGlobalScope =
    self as unknown as DedicatedWorkerGlobalScope;
  ```

## 5. React Development Mode Effects

- **Expected behavior**: React Strict Mode in development may cause useEffect to run multiple times, leading to multiple worker initialization attempts in console logs.
- **Solution**: This is normal in development and won't occur in production. No fix needed.

## 6. Pyodide CDN URLs

- **Consistent indexURL**: Ensure the `indexURL` in `loadPyodide()` matches the CDN version used in `importScripts()`.
- **Example**: If using `@0.28.0/pyodide.min.js`, use `indexURL: "https://cdn.jsdelivr.net/pyodide/v0.28.0/full/"`
